## 适配器模式

> 什么是适配者模式?

把一个东西转为另一个适配需求的东西就是适配器模式 (如: USB 接口,可以通过转换器转为 TypeC接口或者其他接口)

### 适配器模式的实现方式

#### 类适配器

![](http://img.zfqit.top/img/202207221505943.png)


> 类适配器就是通过继承被适配的对象并实现适配接口,来达成类适配器

```java
/**  
 * 被适配对象  
 *  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public class StudentType {  
  
    /**  
     * 例子: 把 Integer 类型的对应的学生类型适配成 boolean 类型来决定老师是否教的是小学生还是高中生  
     * 1 等于 高中生,其他等于小学生  
     * 获取学生类型  
     */  
    public Integer getType(Integer type) {  
        return type;  
    }  
}
```

```java
/**  
 * 适配者接口  
 *  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public interface TeacherAdaptor {  
    boolean studentStudy();  
}
```

```java
/**  
 * 适配者对象  
 *  
 * 因为 Java 中是单继承,所以使用继承被适配者对象时,会导致继承不了其他类  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public class TeacherHighAdaptor extends StudentType implements TeacherAdaptor {  
  
    @Override  
    public boolean studentStudy() {  
        Integer type = super.getType(1);  
        if (type.equals(1)) {  
            return true;  
        } else {  
            return false;  
        }  
    }  
}
```

```java
/**  
 * 使用方  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public class Teacher {  
    public void studyStudent(TeacherAdaptor teacherAdaptor) {  
        System.out.println("老师准备教那种类型的学生学习");  
        if (teacherAdaptor.studentStudy()) {  
            System.out.println("教高中生学习,态度很严厉");  
        } else {  
            System.out.println("教小学生学习,态度很温和");  
        }  
    }  
  
}
```

```java
/**  
 * 测试端  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public class Client {  
    public static void main(String[] args) {  
        new Teacher().studyStudent(new TeacherHighAdaptor());  
        // 如果要新增小学生或其他类型的转换,只需要实现适配器接口,并实现转换方法,即可  
    }  
}
```

#### 对象适配器

![](http://img.zfqit.top/img/202207221506112.png)


> 通过[[UML#类图组合 Composition|组合]]/[[UML#类图聚合 Aggregation|聚合]]的方式来使用被适配的对象,并实现适配接口,来达成对象适配器

```java
/**  
 * 被适配对象  
 *  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public class StudentType {  
  
    /**  
     * 例子: 把 Integer 类型的对应的学生类型适配成 boolean 类型来决定老师是否教的是小学生还是高中生  
     * 1 等于 高中生,其他等于小学生  
     * 获取学生类型  
     */  
    public Integer getType(Integer type) {  
        return type;  
    }  
}
```

```java
/**  
 * 适配者接口  
 *  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public interface TeacherAdaptor {  
    boolean studentStudy();  
}
```

```java
/**  
 * 适配者对象  
 *  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public class TeacherHighAdaptor implements TeacherAdaptor {  
  
    private StudentType studentType;  
  
    public TeacherHighAdaptor(StudentType studentType) {  
        this.studentType = studentType;  
    }  
  
    @Override  
    public boolean studentStudy() {  
        Integer type = this.studentType.getType(1);  
        if (type.equals(1)) {  
            return true;  
        } else {  
            return false;  
        }  
    }  
}
```

```java
/**  
 * 使用方  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public class Teacher {  
    public void studyStudent(TeacherAdaptor teacherAdaptor) {  
        System.out.println("老师准备教那种类型的学生学习");  
        if (teacherAdaptor.studentStudy()) {  
            System.out.println("教高中生学习,态度很严厉");  
        } else {  
            System.out.println("教小学生学习,态度很温和");  
        }  
    }  
  
}
```

```java
/**  
 * 测试端  
 * @author zhoufuqi  
 * @date 2022/7/19  
 */public class Client {  
    public static void main(String[] args) {  
        new Teacher().studyStudent(new TeacherHighAdaptor(new StudentType()));  
        // 如果要新增小学生或其他类型的转换,只需要实现适配器接口,并实现转换方法,即可  
    }  
}
```

#### 接口适配器

> 为什么要使用接口适配器?

接口适配器它的出现是因为不同类的使用方不一定需要适配器接口的所有方法,所以才需要接口适配器

> 接口适配器通过抽象类的方式实现所有的适配器接口的方法的空实现,不同使用方,只需要继承抽象类或(静态内部类覆盖需要实现的方法即可),并覆盖想要实现的适配器方法即可

```java
/**  
 * 适配器接口  
 * @author zhou  
 */public interface InterfaceAdaptor {  
  
    void m1();  
  
    void m2();  
  
    void m3();  
  
    void m4();  
  
}
```

```java
/**  
 * 实现适配器接口的抽象类  
 * @author zhoufuqi  
 * @date 2022/7/19 19:54  
 */public abstract class AbsTeacherAdaptor implements InterfaceAdaptor {  
  
    @Override  
    public void m1() {  
  
    }  
  
    @Override  
    public void m2() {  
  
    }  
  
    @Override  
    public void m3() {  
  
    }  
  
    @Override  
    public void m4() {  
  
    }  
}
```

```java
/**  
 * 测试端  
 * 接口适配器模式,通过抽象类的实现接口方法的默认实现,来为调用方,自己覆盖自己需要的接口,而不需要重写所有的接口  
 *  
 * @author zhoufuqi  
 * @date 2022/7/19 20:03  
 */public class Client {  
    public static void main(String[] args) {  
        AbsTeacherAdaptor adaptor = new AbsTeacherAdaptor() {  
            @Override  
            public void m1() {  
                System.out.println("抽象接口的适配器模式");  
            }  
        };  
        adaptor.m1();  
    }  
}
```


### 桥接模式

> 为什么要使用桥接模式?

如:多个品牌下有相同的一个产品,产品下又有很多不同的类别,使用继承的方式会导致的类膨胀的问题,既: 一旦多一个品牌或多一个类别,都会创建类,这就叫类膨胀

> 桥接模式是把两个不同行为的产品/类别拆分为接口和抽象类,抽象类通过聚合接口的方式,把对应接口的子类传入进来,通过抽象类的(具体行为的)子类进行使用

![](http://img.zfqit.top/img/202207231020665.png)

```java
/**  
 * 糖的吃法的抽象类  
 * 桥接模式  
 * 桥接对象  
 *  
 * @author zhoufuqi  
 * @date 2022/7/22  
 */public abstract class SugarEating {  
  
    private Taste taste;  
  
    public SugarEating(Taste taste) {  
        this.taste = taste;  
    }  
  
    protected void printEating() {  
        taste.printTaste();  
    }  
  
}
```

```java
/**  
 * @author zhoufuqi  
 * @date 2022/7/22  
 */public class DishSugarEating extends SugarEating {  
  
    public DishSugarEating(Taste taste) {  
        super(taste);  
    }  
  
    protected void printDishEating() {  
        System.out.println("炒菜吃法");  
        super.printEating();  
    }  
  
}
```

```java
/**  
 * @author zhoufuqi  
 * @date 2022/7/22  
 */public class WaterSugarEating extends SugarEating {  
  
    public WaterSugarEating(Taste taste) {  
        super(taste);  
    }  
  
    protected void printWaterEating() {  
        System.out.println("泡水吃法");  
        super.printEating();  
    }  
  
  
}
```

```java
/**  
 * 口感  
 *  
 * @author zhoufuqi  
 * @date 2022/7/22  
 */public interface Taste {  
  
    void printTaste();  
  
}
```

```java
/**  
 * @author zhoufuqi  
 * @date 2022/7/22  
 */public class SourTaste implements Taste {  
  
    @Override  
    public void printTaste() {  
        System.out.println("酸口感");  
    }  
  
}
```

```java
/**  
 * @author zhoufuqi  
 * @date 2022/7/22  
 */public class SweetTaste implements Taste {  
  
    @Override  
    public void printTaste() {  
        System.out.println("甜口感");  
    }  
  
}
```

```java
/**  
 * 测试端  
 * @author zhoufuqi  
 * @date 2022/7/22  
 */public class Client {  
    public static void main(String[] args) {  
        WaterSugarEating eat1 = new WaterSugarEating(new SweetTaste());  
        eat1.printWaterEating();  
        System.out.println("--------------------------------");  
        DishSugarEating eat2 = new DishSugarEating(new SourTaste());  
        eat2.printDishEating();  
    }  
}
```

