### 模板方法模式

> 模板方法模式: 为一个产品生产设计一个骨架. 如: 蛋糕的制作流程 糕体 奶油 配料(......) 包装, 而具体产品是通过添加不同的配料而生产不同的产品

注意: 
	模板方法模式中有一个钩子方法. 钩子方法的作用是让子类控制骨架中的方法是否执行

![](http://img.zfqit.top/img/202209191049767.png)

```java
/**  
 * @author zhoufuqi  
 * @date 2022/9/19  
 */public abstract class Cake {  
  
    /**  
     * 制作蛋糕, 也就是通过模板组装蛋糕  
     */  
    final void production() {  
        body();  
        cream();  
        // 钩子方法  
        if (isIngredient()) {  
            addIngredient();  
        }  
        packing();  
    }  
  
    public void body() {  
        System.out.println("制作糕体");  
    }  
  
    /**  
     * 钩子方法: 可以让子类去覆盖,来决定是否执行骨架中的执行逻辑  
     *  
     * @return  
     */  
    public boolean isIngredient() {  
        return false;  
    }  
  
    public abstract void addIngredient();  
  
    public void cream() {  
        System.out.println("制作奶油");  
    }  
  
    public void packing() {  
        System.out.println("包装蛋糕");  
    }  
  
}
```

```java
/**  
 * @author zhoufuqi  
 * @date 2022/9/19  
 */public class ChocolateCake extends Cake {  
  
    @Override  
    public void addIngredient() {  
        System.out.println("添加巧克力");  
    }  
  
    /**  
     * 钩子方法  
     *  
     * @return  
     */  
    @Override  
    public boolean isIngredient() {  
        return true;  
    }  
}
```

```java
/**  
 * @author zhoufuqi  
 * @date 2022/9/19  
 */public class OrdinaryCake extends Cake {  
  
    @Override  
    public void addIngredient() {  
    }  
  
}
```

```java
/**  
 * @author zhoufuqi  
 * @date 2022/9/19  
 */public class StrawberryCake extends Cake {  
  
    @Override  
    public void addIngredient() {  
        System.out.println("添加草莓");  
    }  
  
    /**  
     * 钩子方法: 可以让子类去覆盖,来决定是否执行骨架中的执行逻辑  
     *  
     * @return  
     */  
    @Override  
    public boolean isIngredient() {  
        return true;  
    }  
}
```

```java
/**  
 * 模板模式  
 *  
 * @author zhoufuqi  
 * @date 2022/9/19  
 */public class Client {  
    public static void main(String[] args) {  
        System.out.println("巧克力蛋糕制作方式");  
        Cake chocolateCake = new ChocolateCake();  
        chocolateCake.production();  
  
        System.out.println("草莓蛋糕制作方式");  
        StrawberryCake strawberryCake = new StrawberryCake();  
        strawberryCake.production();  
  
        System.out.println("普通蛋糕制作方式");  
        OrdinaryCake ordinaryCake = new OrdinaryCake();  
        ordinaryCake.production();  
  
    }  
}
```

### 命令模式

> 为什么要使用命令模式?

如: 将军发布一条命令让士兵进攻, 而如果使用传统方式编写代码,则将军类中会聚合士兵类,而有时候将军的命令不一定是发布给士兵的,这样做就会导致要修改将军类,还有一种情况将军发布的命令还不知道由谁执行,则就会导致命令无法得到执行,而命令模式解决了上述两个问题,也符合开闭原则

> 命令模式的作用

将调用者(将军)与执行的人(士兵)进行解耦的作用

优点:
1. 解决调用者和执行者的耦合

缺点:
1. 命令很多时会产生很多个命令类

注意点: 
	空命令可以作为初始化命令或下达不存在命令的一种的执行条件
	作用: 减少判断

![](http://img.zfqit.top/img/202209201546939.png)

```java
/**  
 * 抽象的命令接口,提供执行和撤销的抽象方法  
 *  
 * @author zhoufuqi  
 * @date 2022/9/20  
 */public interface ICommand {  
  
    /**  
     * 执行  
     */  
    void execute();  
  
    /**  
     * 撤销  
     */  
    void undo();  
}
```

```java
/**  
 * 执行者  
 * @author zhoufuqi  
 * @date 2022/9/20  
 */public class Soldier {  
  
    public void attack() {  
        System.out.println("士兵正在进攻");  
    }  
  
    public void retreat() {  
        System.out.println("士兵正在撤退");  
    }  
  
}
```

```java
/**  
 * 撤退命令  
 * @author zhoufuqi  
 * @date 2022/9/20  
 */public class RetreatCommand implements ICommand {  
  
    private Soldier soldier;  
  
    public RetreatCommand(Soldier soldier) {  
        this.soldier = soldier;  
    }  
  
    /**  
     * 执行  
     */  
    @Override  
    public void execute() {  
        soldier.retreat();  
    }  
  
    /**  
     * 撤销  
     */  
    @Override  
    public void undo() {  
        soldier.attack();  
    }  
}
```

```java
/**  
 * 进攻命令  
 * @author zhoufuqi  
 * @date 2022/9/20  
 */public class AttackCommand implements ICommand {  
  
    private Soldier soldier;  
  
    public AttackCommand(Soldier soldier) {  
        this.soldier = soldier;  
    }  
  
    /**  
     * 执行  
     */  
    @Override  
    public void execute() {  
        soldier.attack();  
    }  
  
    /**  
     * 撤销  
     */  
    @Override  
    public void undo() {  
        soldier.retreat();  
    }  
}
```

```java
/**  
 * 空命令  
 *  
 * @author zhoufuqi  
 * @date 2022/9/20  
 */public class NoCommand implements ICommand {  
  
    private Soldier soldier;  
  
    public NoCommand(Soldier soldier) {  
        this.soldier = soldier;  
    }  
  
  
    /**  
     * 执行  
     */  
    @Override  
    public void execute() {  
  
    }  
  
    /**  
     * 撤销  
     */  
    @Override  
    public void undo() {  
  
    }  
}
```

```java
/**  
 * 将军  
 * @author zhoufuqi  
 * @date 2022/9/20  
 */public class General {  
  
    private ICommand revoke;  
  
    private List<ICommand> commands = new ArrayList<>();  
  
    public General() {  
        // 初始化命令3个命令  
        Soldier soldier = new Soldier();  
        commands.add(new RetreatCommand(soldier));  
        commands.add(new AttackCommand(soldier));  
        commands.add(new NoCommand(soldier));  
    }  
  
    public void setCommand(int index, ICommand command) {  
        if (commands.size() -1  < index) {  
            commands.add(command);  
            return;        }  
        commands.set(index, command);  
    }  
  
    /**  
     * 执行命令  
     *  
     * @param index 命令代号  
     */  
    public void execute(int index) {  
        ICommand iCommand = commands.get(index);  
        iCommand.execute();  
        // 记录执行的命令  
        revoke = iCommand;  
    }  
  
    /**  
     * 撤销命令  
     */  
    public void undo() {  
        revoke.undo();  
    }  
  
}
```

```java
/**  
 * 客户端  
 * @author zhoufuqi  
 * @date 2022/9/20  
 */public class Client {  
    public static void main(String[] args) {  
        General general = new General();  
        general.setCommand(3, new AttackCommand(new Soldier()));  
        general.setCommand(4, new RetreatCommand(new Soldier()));  
        System.out.println("执行士兵进攻命令");  
        general.execute(3);  
        System.out.println("撤销士兵进攻命令,则是撤退");  
        general.undo();  
    }  
}
```