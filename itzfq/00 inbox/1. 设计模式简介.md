>什么是设计模式?

设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。
设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本[Design Patterns](https://en.wikipedia.org/wiki/Design_Patterns)的书。这四人也被称为四人帮（GoF）。

>为什么要使用设计模式？

根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的(也就是面向对象设计原则)，它基于以下几个原则:  单一职责原则、开闭原则、里氏替换原则、依赖倒转原则、接口隔离原则、合成复用原则、迪米特法则

## 设计模式原则

> 什么是设计模式原则?

设计模式原则,其实就是编程时,应当遵循的原则,也是各种设计模式的基础(既: 设计模式为什么要这么设计时的依据)

> 总结: 设计模式原则本质上就是提供一种编程规范,不过它也是各种设计模式设计时所依赖的底层思路
> 目的:  解决程序的可维护性、可扩展性、可靠性、可复用性、可读性、并且使程序实现**高内聚**, **低耦合**的特性

面向对象设计原则的目的和作用
![](http://img.zfqit.top/img/202206051605027.png)


### 单一职责原则

单一职责原则（Simple Responsibility Pinciple，SRP）是最简单的面向对象设计原则，它用于控制类的粒度大小。

> 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。

例子:
* 人类(People)
	* 打螺丝
	* 跑外卖
	* 编程

我们可以看到，这个People类可以说是十八般武艺样样精通了，啥都会，但是实际上，我们每个人最终都是在自己所擅长的领域工作，所谓闻道有先后，术业有专攻，会编程的就应该是程序员，会打螺丝的就应该是工人，会送外卖的应该是骑手，显然这个People太过臃肿（我们需要修改任意一种行为都需要修改People类，它拥有不止一个引起它变化的原因），所以根据单一职责原则，我们下需要进行更明确的划分，同种类型的操作我们一般才放在一起：

推荐:
* 打螺丝类
* 跑外卖类
* 编程类

我们将类的粒度进行更近一步的划分，这样就很清晰了，包括我们以后在设计Mapper、Service、Controller等等，根据不同的业务进行划分，都可以采用单一职责原则，以它作为我们实现高内聚低耦合的指导方针。实际上我们的微服务也是参考了单一职责原则，每个微服务只应担负一个职责。

1. **注意事项和细节**
	1. 降低类的复杂性, 一个类只负责一项职责
	2. 提高类的可读性,可维护性
	3. 降低变更引起的风险
	4. 通常情况下,我们应当遵循单一职责原则,只有逻辑足够简单,才可以在代码中违反单一职责原则,只有类中的方法足够少时,可以在方法级别保持单一职责原则
		1. 如: 跑外卖方法,需要接单, 看地址, 开车等一系列能引起代码变化的.这时就需要使用类级别的单一职责原则来进行拆分


> 总结: 单一职责原则本质上就是一个类把能引起类变化的行为,拆分的更加细,让每个类只应担负一个职责(也就是**各司其职**)

### 开闭原则

开闭原则（Open Close Principle）也是重要的面向对象设计原则。

> 软件实体应当对扩展开放，对修改关闭。

一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭。其中，对扩展开放是针对提供方来说的，对修改关闭是针对调用方来说的。
比如我们的程序员分为Java程序员、C#程序员、C艹程序员、PHP程序员、前端程序员等，而他们要做的都是去打代码，而具体如何打代码是根据不同语言的程序员来决定的，我们可以将程序员打代码这一个行为抽象成一个统一的接口或是抽象类，这样我们就满足了开闭原则的第一个要求：对扩展开放，不同的程序员可以自由地决定他们该如何进行编程。而具体哪个程序员使用什么语言怎么编程，是自己在负责，不需要其他程序员干涉，所以满足第二个要求：对修改关闭, 比如：
```java
public abstract class Coder {

    public abstract void coding();

    class JavaCoder extends Coder{
        @Override
        public void coding() {
            System.out.println("Java太卷了T_T，快去学Go吧！");
        }
    }

    class PHPCoder extends Coder{
        @Override
        public void coding() {
            System.out.println("PHP是世界上最好的语言");
        }
    }

    class C艹Coder extends Coder{
        @Override
        public void coding() {
            System.out.println("笑死，Java再牛逼底层不还得找我？");
        }
    }
}
```
通过提供一个Coder抽象类，定义出编程的行为，但是不进行实现，而是开放给其他具体类型的程序员来实现，这样就可以根据不同的业务进行灵活扩展了，具有较好的延续性。

> 总结:  开闭原则本质上就是对扩展开放,对修改关闭,具体实现方式通过抽象类和接口来实现

### 里氏替换原则

里氏替换原则（Liskov Substitution Principle）是对子类型的特别定义。它由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为 “数据的抽象与层次” 的演说中首先提出。
> 所有引用基类的地方必须能透明地使用其子类的对象。

里氏替换原则中关于继承性的思考和说明
-   继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在**设定规范和契约**，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏
-   **继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性**，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障

简单的说就是，子类可以扩展父类的功能，但不能改变父类原有的功能:  ^4ac6a9
1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
2. 子类可以增加自己特有的方法。
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。
4. 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或与父类一样。

里氏替换原则注意事项:
1. 继承关系导致父类和子类的耦合性增强了,在适当的情况下可以使用 **聚合**.**组合**.**依赖**来解决问题

违反里氏替换原则例子:
```java
package com.zhou.designPrinciples.liskov;  
  
/**  
 * 违反里氏替换原则  
 *  
 * @author zhoufuqi  
 * @date 2022/6/7  
 */public class LiskovDemo1 {  
    public static void main(String[] args) {  
        A a = new A();  
        System.out.println(a.fun1(11, 3));  
        System.out.println(a.fun1(8, 3));  
        System.out.println("----------------");  
  
        // 没有使用里氏替换原则的缺点  
        // 1. 方法之间描述不清楚.因为继承B类继承A类,b类中忘记了覆盖了A的计算差价的方法,导致方法和方法含义有歧义  
        // 2. 随意覆盖父类的方法会导致整个继承关系的崩坏.  
        // 因为B类覆盖了父类的方法,一旦后续有继承B类的子类的话,那子类中的方法就会变成父类覆盖后的方法,这样导致整个继承关系的崩坏  
        // 解决方案:  
        // 通用的方案:抽出一个通用的基类, 把原有的继承关系去掉,采用依赖.聚合.组合关系代替  
        // 里氏替换原则解决方案: 不要重写父类的方法,新增自己的方法  
        B b = new B();  
        System.out.println(b.fun2(10, 2));  
    }  
}  
  
class A {  
    /**  
     * 计算两数之间的差  
     *  
     * @param a  
     * @param b  
     * @return  
     */  
    public Integer fun1(Integer a, Integer b) {  
        return a - b;  
    }  
}  
  
class B extends A {  
  
    public Integer fun1(Integer a, Integer b) {  
        return a + b;  
    }  
  
    public Integer fun2(Integer a, Integer b) {  
        return fun1(a, b) + 9;  
    }  
}
```
使用依赖.聚合.组合方式的例子:
```java
package com.zhou.designPrinciples.liskov.imporve;  
  
/**  
 * 里氏替换原则  
 *  
 * @author zhoufuqi  
 * @date 2022/6/7  
 */public class LiskovDemo1 {  
    public static void main(String[] args) {  
        A a = new A();  
        System.out.println(a.fun1(11, 3));  
        System.out.println(a.fun1(8, 3));  
        System.out.println("----------------");  
  
        // 解决方案:  
        // 通用的方案:抽出一个通用的基类, 把原有的继承关系去掉,采用依赖.聚合.组合关系代替  
        B b = new B();  
        // 优点  
        // 1. 因为使用了依赖.聚合.组合方式使方法的调用更加明确了  
        // 2. 使用依赖.聚合.组合方式,任然可以使用A类中的方法  
        System.out.println(b.fun2(10, 2));  
        System.out.println(b.fun3(10, 2));  
    }  
}  
  
class Base {  
}  
  
class A extends Base {  
    /**  
     * 计算两数之间的差  
     *  
     * @param a  
     * @param b  
     * @return  
     */  
    public Integer fun1(Integer a, Integer b) {  
        return a - b;  
    }  
}  
  
class B {  
  
    /**  
     * 如果B类要使用A类,就要使用组合关系  
     */  
    private A a = new A();  
  
    public Integer fun1(Integer a, Integer b) {  
        return a + b;  
    }  
  
    public Integer fun2(Integer a, Integer b) {  
        return fun1(a, b) + 9;  
    }  
  
    public Integer fun3(Integer a, Integer b) {  
        return this.a.fun1(a, b) - 9;  
    }  
}
```

> 总结:  里氏替换原则就是子类可以扩展父类的功能,但不能覆盖父类的原有的功能 具体查看[[1. 设计模式简介#^4ac6a9]] ,在适当的情况下可以使用 **聚合**.**组合**.**依赖**来解决继承耦合性高的问题

### 依赖倒转原则

1. 依赖倒转原则（Dependence Inversion Principle）指的是
	1. 高层模块不应依赖于底层模块，它们都应该依赖抽象
	2. **抽象不应依赖于细节，细节应该依赖于抽象**
	3. 依赖倒转的中心思想是**面向接口编程**
		1. 依赖倒转的设计理念是: 相对细节的变化,抽象的东西则要稳定的多, 以抽象为基础搭建的架构比细节为基础的架构要稳定的多. 在Java 中 抽象指的是接口或抽象类,细节是具体的实现
	4. 使用**接口或抽象类**的目的是指定好**规范**,而不涉及具体细节实现
2. 注意事项和细节
	1. 底层模块尽量都要有抽象类或接口,或者两者都有,能提高程序的稳定性
	2. 变量的声明尽量是抽象类或接口,因为使用了抽象类或接口作为变量时,引用时就多了一个缓冲层(也就是实现类),利于程序的扩展
	3. 继承时遵循里氏替换原则

没有使用依赖倒转例子:
```java
package com.zhou.designPrinciples.inversion;  
  
/**  
 * 违反口依赖原则  
 * @author zhoufuqi  
 * @date 2022/6/7  
 */public class DependencyInversionDemo1 {  
    public static void main(String[] args) {  
        Person person = new Person();  
        person.receive(new Email());  
        person.receive(new WeiXi());  
    }  
}  
  
/**  
 * 方式1  
 * 1. 简单,方便  
 * 2. 接收邮件消息, 一旦我需要接收短信 微信消息等功能时,接收消息时,则需要增加不同类,并且要新增方法  
 * 这样导致代码稳定性和可扩展性降低  
 * 解决方案: 通过引入一个抽象接口IReceive,表示接收者,这样Person类与接口进行依赖  
 */  
class Person {  
    public void receive(Email email) {  
        System.out.println(email.getInfo());  
    }  
  
    public void receive(WeiXi weiXi){  
        System.out.println(weiXi.getInfo());  
    }  
}  
  
class Email {  
    public String getInfo() {  
        return "电子邮件: hello world";  
    }  
}  
  
class WeiXi {  
    public String getInfo(){  
        return "微信: hello wx";  
    }  
}
```
使用了依赖倒转原则后:
```java
package com.zhou.designPrinciples.inversion.imporve;  
  
/**  
 * 依赖倒转原则  
 * @author zhoufuqi  
 * @date 2022/6/7  
 */public class DependencyInversionDemo2 {  
    public static void main(String[] args) {  
        Person person = new Person();  
        person.receive(new Email());  
        person.receive(new WeiXi());  
    }  
}  
  
interface IReceive {  
    String getInfo();  
}  
  
/**  
 * 方式 2  
 * 使用依赖倒转原则,可以让被依赖类中不新增方法,使程序的稳定性提高和扩展性提高  
 */  
class Person {  
    public void receive(IReceive receive) {  
        System.out.println(receive.getInfo());  
    }  
}  
  
class Email implements IReceive {  
  
    @Override  
    public String getInfo() {  
        return "电子邮件: hello world";  
    }  
}  
  
class WeiXi implements IReceive{  
    @Override  
    public String getInfo() {  
        return "微信: hello wx";  
    }  
}
```

实现依赖倒转传参的三种方式
```java
package com.zhou.designPrinciples.inversion.imporve;  
  
/**  
 * 依赖倒转原则  
 *  
 * @author zhoufuqi  
 * @date 2022/6/7  
 */public class DependencyInversionDemo3 {  
    public static void main(String[] args) {  
        // Setter 方法  
        Person1 person = new Person1();  
        person.setReceive(new WeiXi());  
        person.receive1();  
  
        // 构造器  
        Person1 person1 = new Person1(new Email());  
        person1.receive1();  
    }  
}  
  
interface IReceive1 {  
    String getInfo();  
}  
  
/**  
 * 依赖方式: 通过参数传递实现依赖倒转  
 */  
class Person1 {  
    private IReceive receive;  
  
    /**  
     * 通过构造器方式实现依赖倒转  
     *  
     * @param iReceive  
     */  
    public Person1(IReceive iReceive) {  
        this.receive = iReceive;  
    }  
  
    public Person1() {  
    }  
  
    /**  
     * 通过Setter方式实现依赖倒转  
     *  
     * @param iReceive  
     */  
    public void setReceive(IReceive iReceive) {  
        this.receive = iReceive;  
    }  
  
    /**  
     * 通过该方法实现set和构造器依赖倒转  
     */  
    public void receive1() {  
        System.out.println(this.receive.getInfo());  
    }  
  
  
    public void receive(IReceive1 receive) {  
        System.out.println(receive.getInfo());  
    }  
  
  
}  
  
class Email1 implements IReceive1 {  
  
    @Override  
    public String getInfo() {  
        return "电子邮件: hello world";  
    }  
}  
  
class WeiXi1 implements IReceive1 {  
    @Override  
    public String getInfo() {  
        return "微信: hello wx";  
    }  
}
```

> 总结: 依赖倒转原则本质上就是把程序中依赖于的细节的类,给替换成依赖接口或抽象类的方式,让抽象类或接口的实现类来实现具体的细节,这样的方式就是依赖倒转原则

### 接口隔离原则

接口隔离原则（Interface Segregation Principle, ISP）实际上是对接口的细化。

> 客户端不应依赖那些它不需要的接口。

我们在定义接口的时候，一定要注意控制接口的粒度，比如下面的例子：
```java
package com.zhou.designPrinciples.segregation;  
  
/**  
 * 违反接口隔离原则例子  
 *  
 * @author zhoufuqi  
 * @date 2022/6/7  
 */public class SegregationDome1 {  
    public static void main(String[] args) {  
        // 这种接口依赖关系导致不同类型的类实现了接口中的所有方法  
        // 但是有些类又不需要实现其他类中接口的方法,而且也必须实现  
        // 这样就违反了接口隔离原则  
        // 解决方法就是把接口拆分的更细,让每个类依赖接口的类实现最少的方法  
        A a = new A();  
        a.depend1(new B());  
        a.depend2(new B());  
        a.depend3(new B());  
  
        D d = new D();  
        d.depend1(new C());  
        d.depend4(new C());  
        d.depend5(new C());  
    }  
}  
  
interface Interface1 {  
    void operation1();  
  
    void operation2();  
  
    void operation3();  
  
    void operation4();  
  
    void operation5();  
}  
  
/**  
 * A 要 依赖 B类中的1, 2, 3 方法  
 */  
class A {  
    public void depend1(Interface1 interface1) {  
        interface1.operation1();  
    }  
  
    public void depend2(Interface1 interface1) {  
        interface1.operation2();  
    }  
  
    public void depend3(Interface1 interface1) {  
        interface1.operation3();  
    }  
}  
  
/**  
 * D 要 依赖 B类中的1, 4, 5 方法  
 */  
class D {  
    public void depend1(Interface1 interface1) {  
        interface1.operation1();  
    }  
  
    public void depend4(Interface1 interface1) {  
        interface1.operation4();  
    }  
  
    public void depend5(Interface1 interface1) {  
        interface1.operation5();  
    }  
}  
  
  
class C implements Interface1 {  
  
    @Override  
    public void operation1() {  
        System.out.println("C = operation1");  
    }  
  
    @Override  
    public void operation2() {  
        System.out.println("C = operation2");  
    }  
  
    @Override  
    public void operation3() {  
        System.out.println("C = operation3");  
    }  
  
    @Override  
    public void operation4() {  
        System.out.println("C = operation4");  
    }  
  
    @Override  
    public void operation5() {  
        System.out.println("C = operation5");  
    }  
}  
  
class B implements Interface1 {  
    @Override  
    public void operation1() {  
        System.out.println("B = operation1");  
    }  
  
    @Override  
    public void operation2() {  
        System.out.println("B = operation2");  
    }  
  
    @Override  
    public void operation3() {  
        System.out.println("B = operation3");  
    }  
  
    @Override  
    public void operation4() {  
        System.out.println("B = operation4");  
    }  
  
    @Override  
    public void operation5() {  
        System.out.println("B = operation5");  
    }  
}
```
虽然我们定义了一个Inteface接口，但是由于此接口的粒度不够细, 导致其他接口实现了本不该实现的接口这时我们就必须要对其进行更细粒度的划分：
```java
package com.zhou.designPrinciples.segregation.imporve;  
  
/**  
 * 接口隔离原则,拆分方式  
 *  
 * @author zhoufuqi  
 * @date 2022/6/7  
 */public class SegregationDome2 {  
    public static void main(String[] args) {  
        A a = new A();  
        a.depend1(new B());  
        a.depend2(new B());  
        a.depend3(new B());  
  
        D d = new D();  
        d.depend1(new C());  
        d.depend4(new C());  
        d.depend5(new C());  
    }  
}  
  
interface Interface1 {  
    void operation1();  
}  
  
interface Interface2 {  
    void operation2();  
  
    void operation3();  
}  
  
interface Interface3 {  
    void operation4();  
  
    void operation5();  
}  
  
/**  
 * A 要 依赖 B类中的1, 2, 3 方法  
 */  
class A {  
    public void depend1(Interface1 interface1) {  
        interface1.operation1();  
    }  
  
    public void depend2(Interface2 interface2) {  
        interface2.operation2();  
    }  
  
    public void depend3(Interface2 interface2) {  
        interface2.operation3();  
    }  
}  
  
/**  
 * D 要 依赖 B类中的1, 4, 5 方法  
 */  
class D {  
    public void depend1(Interface1 interface1) {  
        interface1.operation1();  
    }  
  
    public void depend4(Interface3 interface3) {  
        interface3.operation4();  
    }  
  
    public void depend5(Interface3 interface3) {  
        interface3.operation5();  
    }  
}  
  
  
class B implements Interface1, Interface2 {  
  
    @Override  
    public void operation1() {  
        System.out.println("B = operation1");  
    }  
  
    @Override  
    public void operation2() {  
        System.out.println("B = operation2");  
    }  
  
    @Override  
    public void operation3() {  
        System.out.println("B = operation3");  
    }  
}  
  
class C implements Interface1, Interface3 {  
  
    @Override  
    public void operation1() {  
        System.out.println("C = operation1");  
    }  
  
    @Override  
    public void operation4() {  
        System.out.println("C = operation4");  
  
    }  
  
    @Override  
    public void operation5() {  
        System.out.println("C = operation5");  
    }  
}
```
这样，我们就将接口进行了细粒度的划分，不同类型类就可以根据划分去实现不同的接口了。当然，也不能划分得太小，还是要根据实际情况来进行决定。

> 总结: 接口隔离原则本质上就是把接口进行更细腻的拆分,不同类型的类实现不同类型拆分的接口,但是拆分的力度还是需要按照实际来决定,

### 合成复用原则

合成复用原则（Composite Reuse Principle）的核心就是委派。

> 优先使用对象组合，而不是通过继承来达到复用的目的。

在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象的委派达到复用已有功能的目的。实际上我们在考虑将某个类通过继承关系在子类得到父类已经实现的方法之外（比如A类实现了连接数据库的功能，恰巧B类中也需要，我们就可以通过继承来获得A已经写好的连接数据库的功能，这样就能直接复用A中已经写好的逻辑）我们应该应该优先地去考虑使用合成的方式来实现复用。

比如下面这个例子：
```java
class A {
    public void connectDatabase(){
        System.out.println("我是连接数据库操作！");
    }
}

class B extends A{    //直接通过继承的方式，得到A的数据库连接逻辑
    public void test(){
        System.out.println("我是B的方法，我也需要连接数据库！");
        connectDatabase();   //直接调用父类方法就行
    }
}
```
虽然这样看起来没啥毛病，但是还是存在我们之前说的那个问题，耦合度太高了。

可以看到通过继承的方式实现复用，我们是将类B直接指定继承自类A的，那么如果有一天，由于业务的更改，我们的数据库连接操作，不再由A来负责，而是由新来的C去负责，那么这个时候，我们就不得不将需要复用A中方法的子类全部进行修改，很显然这样是费时费力的。

并且还有一个问题就是，通过继承子类会得到一些父类中的实现细节，比如某些字段或是方法，这样直接暴露给子类，并不安全。

所以，当我们需要实现复用时，可以优先考虑以下操作：
```java
class A {
    public void connectDatabase(){
        System.out.println("我是连接数据库操作！");
    }
}

class B {   //不进行继承，而是在用的时候给我一个A，当然也可以抽象成一个接口，更加灵活
    public void test(A a){
        System.out.println("我是B的方法，我也需要连接数据库！");
        a.connectDatabase();   //在通过传入的对象A去执行
    }
}
```
或者:
```java
class A {
    public void connectDatabase(){
        System.out.println("我是连接数据库操作！");
    }
}

class B {
    
    A a;
    public B(A a){   //在构造时就指定好
        this.a = a;
    }
    
    public void test(){
        System.out.println("我是B的方法，我也需要连接数据库！");
        a.connectDatabase();   //也是通过对象A去执行
    }
}
```
通过对象之间的组合，我们就大大降低了类之间的耦合度，并且A的实现细节我们也不会直接得到了。

> 总结: 合成复用原则本质上就是本来通过继承方式实现功能的复用,改为使用属性和方法来实现功能的复用
> 好处: 
> 1. 解决由于业务的更改导致父类原本的功能迁移到其他类,导致依赖父类的类全部需要修改
> 2. 通过继承子类会得到一些父类中的实现细节,直接暴露给子类，并不安全

### 迪米特法则

迪米特法则（Law of Demeter）又称最少知识原则，是对程序内部数据交互的限制。

> 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

简单来说就是，一个类/模块对其他的类/模块有越少的交互越好。当一个类发生改动，那么，与其相关的类（比如用到此类啥方法的类）需要尽可能少的受影响（比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改）这样我们在维护项目的时候会更加轻松一些。

其实说白了，还是降低耦合度，我们还是来看一个例子：
```java
public class Main {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("localhost", 8080);   //假设我们当前的程序需要进行网络通信
        Test test = new Test();
        test.test(socket);   //现在需要执行test方法来做一些事情
    }

    static class Test {
        /**
         * 比如test方法需要得到我们当前Socket连接的本地地址
         */
        public void test(Socket socket){
            System.out.println("IP地址："+socket.getLocalAddress());
        }
    }
}
```
可以看到，虽然上面这种写法没有问题，我们提供直接提供一个Socket对象，然后再由test方法来取出IP地址，但是这样显然违背了迪米特法则，实际上这里的test方法只需要一个IP地址即可，我们完全可以直接传入一个字符串，而不是整个Socket对象，我们需要保证与其他类的交互尽可能的少。

就像我们在餐厅吃完了饭，应该是我们自己扫码付款，而不是直接把手机交给老板来帮你操作付款。

要是某一天，Socket类中的这些方法发生修改了，那我们就得连带着去修改这些类，很麻烦。

所以，我们来改进改进：
```java
public class Main {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("localhost", 8080);
        Test test = new Test();
        test.test(socket.getLocalAddress().getHostAddress());  //在外面解析好就行了
    }

    static class Test {
        public void test(String str){   //一个字符串就能搞定，就没必要丢整个对象进来
            System.out.println("IP地址："+str);
        }
    }
}
```
这样，类与类之间的耦合度再次降低。

> 总结: 迪米特法则本质上就是一个类/模块对其他的类/模块有越少的交互越好,这样就减少了依赖,也就是减少了耦合
