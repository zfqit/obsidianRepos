## 创建形设计模式

### 单例设计模式

> 单例模式就是在整个系统中,**某一个类只能存在一个对象实例**,并且该类只提供一个获取其对象的实例的方法(静态方法)

#### 饿汉式(静态成员属性)单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 缺点: 不是懒加载, 如果没有用到该对象,会照成内存浪费, 单线程(推荐)  
 * 饿汉式(静态成员属性)单例设计模式  
 * 单线程推荐使用  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome1 {  
    public static void main(String[] args) {  
        Singleton1 instance1 = Singleton1.getInstance();  
        Singleton1 instance2 = Singleton1.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton1 {  
  
    // 在属性中直接创建对象  
    private static final Singleton1 instance = new Singleton1();  
  
    //  私有构造方法  
    private Singleton1() {  
    }  
  
    // 提供方法返回单例对象  
    public static Singleton1 getInstance() {  
        return instance;  
    }  
  
}
```

#### 饿汉式(静态代码块)单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 缺点: 不是懒加载, 如果没有用到该对象,会照成内存浪费, 单线程(推荐)  
 * 饿汉式(静态代码块)单例设计模式  
 * 单线程推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome2 {  
    public static void main(String[] args) {  
        Singleton2 instance1 = Singleton2.getInstance();  
        Singleton2 instance2 = Singleton2.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton2 {  
  
    private static final Singleton2 instance;  
  
    // 在静态代码块中直接创建对象  
    static {  
        instance = new Singleton2();  
    }  
  
    //  私有构造方法  
    private Singleton2() {  
    }  
  
    // 提供方法返回单例对象  
    public static Singleton2 getInstance() {  
        return instance;  
    }  
  
}
```

#### 单例设计模式 (线程不安全)

```java
package com.zhou.singleton;  
  
/**  
 * 缺点: 多线程环境创建对象不安全,如 A B 线程同时进入if判断,则会创建两次实例  
 * 懒加载单例设计模式  
 * 不推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome3 {  
    public static void main(String[] args) {  
        Singleton3 instance1 = Singleton3.getInstance();  
        Singleton3 instance2 = Singleton3.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton3 {  
  
    private static Singleton3 instance;  
  
    //  私有构造方法  
    private Singleton3() {  
    }  
  
    // 判断对象是否被创建,创建了就直接返回该对象,没有创建,则创建  
    // 但是多线程环境不适用, 会照成线程不安全  
    public static Singleton3 getInstance() {  
        if (instance == null) {  
            return new Singleton3();  
        }  
        return instance;  
    }  
  
}
```

#### 懒汉式单例设计模式 (线程安全)

```java
package com.zhou.singleton;  
  
/**  
 * 线程安全的单例设计模式  
 * 懒加载单例设计模式  
 * 不推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome4 {  
    public static void main(String[] args) {  
        Singleton4 instance1 = Singleton4.getInstance();  
        Singleton4 instance2 = Singleton4.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton4 {  
  
    private static Singleton4 instance;  
  
    //  私有构造方法  
    private Singleton4() {  
    }  
  
    // 线程安全的创建对象的方法  
    // 但是会造成性能问题,因为每一个线程进入都需要加锁,解锁, 而我们只需要第一次线程加锁,后续不需要  
    public static synchronized Singleton4 getInstance() {  
        if (instance == null) {  
            return new Singleton4();  
        }  
        return instance;  
    }  
  
}
```

#### 懒汉式双重检查单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 解决效率问题和懒加载  
 * 双重检查单例设计模式 (完美解决线程不安全问题和执行效率问题)  
 * 懒加载单例设计模式  
 * 推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome5 {  
    public static void main(String[] args) {  
        Singleton5 instance1 = Singleton5.getInstance();  
        Singleton5 instance2 = Singleton5.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton5 {  
  
    private static volatile Singleton5 instance;  
  
    //  私有构造方法  
    private Singleton5() {  
    }  
  
    // 线程安全的创建对象的方法,解决效率问题  
    public static Singleton5 getInstance() {  
        if (instance == null) {  
            synchronized (Singleton5.class) {  
                if (instance == null) {  
                    return new Singleton5();  
                }  
            }  
        }  
        return instance;  
    }  
  
}
```

#### 懒汉式静态内部类的方式创建单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 解决效率问题,和懒加载问题  
 * 静态内部类的方式创建单例设计模式  
 * 懒加载单例设计模式  
 * 推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome6 {  
    public static void main(String[] args) {  
        Singleton6 instance1 = Singleton6.getInstance();  
        Singleton6 instance2 = Singleton6.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton6 {  
  
    // 静态内部内方式创建单例设计模式, 利用jdk 静态内部类特点  
    private static class SingletonInstance {  
        private static final Singleton6 INSTANCE = new Singleton6();  
    }  
  
    //  私有构造方法  
    private Singleton6() {  
    }  
  
    // 线程安全的创建对象的方法,解决效率问题  
    public static Singleton6 getInstance() {  
        return SingletonInstance.INSTANCE;  
    }  
  
}
```

#### 枚举创建单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 枚举创建单例设计模式  
 * 懒加载单例设计模式  
 * 推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome7 {  
    public static void main(String[] args) {  
        Singleton7 instance1 = Singleton7.getInstance();  
        Singleton7 instance2 = Singleton7.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
enum Singleton7 {  
    INSTANCE;  
  
    public static Singleton7 getInstance() {  
        System.out.println("INSTANCE = ok ");  
        return INSTANCE;  
    }  
  
  
}
```

## 工厂模式

> 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
> 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

* 工厂模式优点：
	-   **可以使代码结构清晰，有效地封装变化**。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。
	-   **对调用者屏蔽具体的产品类**。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。
	-   **降低耦合度**。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。

总结
	就是通过工厂模式**不会向客户端暴露创建对象的逻辑**和**屏蔽具体的创建的类的对象**和**降低代码耦合度**

### 简单工厂模式

> 简单工厂模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象
> 简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为**静态工厂方法**模式

* 优点:
	-   一个调用者想创建一个对象，只要知道其名称就可以了。
	-   屏蔽产品的具体实现，调用者只关心产品的接口。

存在的问题:
> 当我们需要增加一种披萨时，例如培根披萨。这个时候我们需要先定义一个类继承 Pizza 类，其中实现准备披萨原材料的代码。除此之外我们还要修改 SimpleFactory 类的代码，增加一个 case/if。这显然是**违背开闭原则**的。可想而知对于新产品的加入，工厂类是很被动的。
> 我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。 简单工厂可能就不太适用了。为了解决这种问题就用到了工厂方法模式了

总结:
	简单工厂模式是通过外接传入的类型,创建相对应的类, **它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了**

### 工厂方法模式

> 定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。
> 工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——工厂方法模式在设计上完全完全符合**开闭原则**。

* 优点:
	-   一个调用者想创建一个对象，只要知道其名称就可以了。
	-   扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
	-   屏蔽产品的具体实现，调用者只关心产品的接口。

缺点:
	每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

总结: 
	工厂方法模式也就是使用面向对象中的多态来实现不同工厂类生产的产品不一样的区别,调用方只需要知道生产产品的工厂然后调用生产产品的对象就行了

### 抽象工厂模式

> 工厂方法模式存在的问题:
> 每生产一个对象,都需要创建一个产品对应的工厂类

抽象工厂模式解决了工厂方法模式中的每一个产品对应一个工厂类的结构,而改变成每一个工厂类,只创建相同类型的产品,也就是树结构

## 原型模式

> 通过复制现有实例来创建新的实例，无需知道相应类的信息。用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。

> 其实就是当需要创建一个指定的对象时，我们刚好有一个这样的对象，但是又不能直接使用，我会clone一个一毛一样的新对象来使用,主要是通过实现 Cloneable 接口并重写 clone 方法

* 优点:
	-   Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
	-   可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

* 原型模式的缺点
  * 需要为每一个类都配置一个 clone 方法
  * clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
  * 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。(也可以通过序列化实现深拷贝)

### 实现

原型模式的克隆分为浅克隆和深克隆。
1. 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
2. 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

>  推荐使用序列化深拷贝

浅拷贝案例
```java
public class Dog implements Cloneable, Serializable {
    private String name;

    public Dog(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                '}';
    }

    /**
     * 使用 Clone 方法实现深拷贝
     *
     * @return
     * @throws CloneNotSupportedException
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

```

```java
public class User implements Cloneable, Serializable {
    private String name;
    private Integer age;
    private Dog dog;

    public User() {
    }

    public User(String name, Integer age, Dog dog) {
        this.name = name;
        this.age = age;
        this.dog = dog;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" + "name='" + name + '\'' + ", age=" + age + ", dog=" + dog + '}';
    }

    /**
     * 通过实现 Cloneable 接口的 clone 方法实现深拷贝 (不推荐)
     *
     * @return
     * @throws CloneNotSupportedException
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
        User user = (User) super.clone();
        Dog dog = (Dog) user.getDog().clone();
        user.setDog(dog);
        return user;
    }


    /**
     * 通过序列化的形式进行深拷贝
     * 注意: 被克隆的对象或属性需要实现 Serializable 接口
     * @return
     */
    public Object deepClone() {
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;
        try {
            // 序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this);
            // 反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            return ois.readObject();
        } catch (Exception e) {

        } finally {
            try {
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }

}
```

```java
public class Client {
    public static void main(String[] args) {
        // 通过 Cloneable 接口的 clone 方法实现深拷贝
        User user = new User("小牛", 29, new Dog("小花"));
        try {
            User user1 = (User) user.clone();
            System.out.println("user1 = " + user1 + "user1 = " + user1.hashCode());
            User user2 = (User) user.clone();
            System.out.println("user2 = " + user2 + "user2 = " + user2.hashCode());
            User user3 = (User) user.clone();
            System.out.println("user3 = " + user3 + "user3 = " + user3.hashCode());
            User user4 = (User) user.clone();
            System.out.println("user4 = " + user4 + "user4 = " + user4.hashCode());
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

        System.out.println("-------------------------------------------------------------");


        // 通过序列化实现深拷贝
        try {
            System.out.println(user.getDog().hashCode());
            User user5 = (User) user.deepClone();
            System.out.println("user5 = " + user5 + "user5 = " + user5.getDog().hashCode());
            User user6 = (User) user.deepClone();
            System.out.println("user6 = " + user6 + "user6 = " + user6.getDog().hashCode());
        } catch (Exception e) {
            e.printStackTrace();
        }


    }
}
```
