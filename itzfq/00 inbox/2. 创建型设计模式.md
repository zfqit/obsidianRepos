## 创建形设计模式

### 单例设计模式

> 单例模式就是在整个系统中,**某一个类只能存在一个对象实例**,并且该类只提供一个获取其对象的实例的方法(静态方法)

#### 饿汉式(静态成员属性)单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 缺点: 不是懒加载, 如果没有用到该对象,会照成内存浪费, 单线程(推荐)  
 * 饿汉式(静态成员属性)单例设计模式  
 * 单线程推荐使用  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome1 {  
    public static void main(String[] args) {  
        Singleton1 instance1 = Singleton1.getInstance();  
        Singleton1 instance2 = Singleton1.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton1 {  
  
    // 在属性中直接创建对象  
    private static final Singleton1 instance = new Singleton1();  
  
    //  私有构造方法  
    private Singleton1() {  
    }  
  
    // 提供方法返回单例对象  
    public static Singleton1 getInstance() {  
        return instance;  
    }  
  
}
```

#### 饿汉式(静态代码块)单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 缺点: 不是懒加载, 如果没有用到该对象,会照成内存浪费, 单线程(推荐)  
 * 饿汉式(静态代码块)单例设计模式  
 * 单线程推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome2 {  
    public static void main(String[] args) {  
        Singleton2 instance1 = Singleton2.getInstance();  
        Singleton2 instance2 = Singleton2.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton2 {  
  
    private static final Singleton2 instance;  
  
    // 在静态代码块中直接创建对象  
    static {  
        instance = new Singleton2();  
    }  
  
    //  私有构造方法  
    private Singleton2() {  
    }  
  
    // 提供方法返回单例对象  
    public static Singleton2 getInstance() {  
        return instance;  
    }  
  
}
```

#### 单例设计模式 (线程不安全)

```java
package com.zhou.singleton;  
  
/**  
 * 缺点: 多线程环境创建对象不安全,如 A B 线程同时进入if判断,则会创建两次实例  
 * 懒加载单例设计模式  
 * 不推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome3 {  
    public static void main(String[] args) {  
        Singleton3 instance1 = Singleton3.getInstance();  
        Singleton3 instance2 = Singleton3.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton3 {  
  
    private static Singleton3 instance;  
  
    //  私有构造方法  
    private Singleton3() {  
    }  
  
    // 判断对象是否被创建,创建了就直接返回该对象,没有创建,则创建  
    // 但是多线程环境不适用, 会照成线程不安全  
    public static Singleton3 getInstance() {  
        if (instance == null) {  
            return new Singleton3();  
        }  
        return instance;  
    }  
  
}
```

#### 懒汉式单例设计模式 (线程安全)

```java
package com.zhou.singleton;  
  
/**  
 * 线程安全的单例设计模式  
 * 懒加载单例设计模式  
 * 不推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome4 {  
    public static void main(String[] args) {  
        Singleton4 instance1 = Singleton4.getInstance();  
        Singleton4 instance2 = Singleton4.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton4 {  
  
    private static Singleton4 instance;  
  
    //  私有构造方法  
    private Singleton4() {  
    }  
  
    // 线程安全的创建对象的方法  
    // 但是会造成性能问题,因为每一个线程进入都需要加锁,解锁, 而我们只需要第一次线程加锁,后续不需要  
    public static synchronized Singleton4 getInstance() {  
        if (instance == null) {  
            return new Singleton4();  
        }  
        return instance;  
    }  
  
}
```

#### 懒汉式双重检查单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 解决效率问题和懒加载  
 * 双重检查单例设计模式 (完美解决线程不安全问题和执行效率问题)  
 * 懒加载单例设计模式  
 * 推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome5 {  
    public static void main(String[] args) {  
        Singleton5 instance1 = Singleton5.getInstance();  
        Singleton5 instance2 = Singleton5.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton5 {  
  
    private static volatile Singleton5 instance;  
  
    //  私有构造方法  
    private Singleton5() {  
    }  
  
    // 线程安全的创建对象的方法,解决效率问题  
    public static Singleton5 getInstance() {  
        if (instance == null) {  
            synchronized (Singleton5.class) {  
                if (instance == null) {  
                    return new Singleton5();  
                }  
            }  
        }  
        return instance;  
    }  
  
}
```

#### 懒汉式静态内部类的方式创建单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 解决效率问题,和懒加载问题  
 * 静态内部类的方式创建单例设计模式  
 * 懒加载单例设计模式  
 * 推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome6 {  
    public static void main(String[] args) {  
        Singleton6 instance1 = Singleton6.getInstance();  
        Singleton6 instance2 = Singleton6.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton6 {  
  
    // 静态内部内方式创建单例设计模式, 利用jdk 静态内部类特点  
    private static class SingletonInstance {  
        private static final Singleton6 INSTANCE = new Singleton6();  
    }  
  
    //  私有构造方法  
    private Singleton6() {  
    }  
  
    // 线程安全的创建对象的方法,解决效率问题  
    public static Singleton6 getInstance() {  
        return SingletonInstance.INSTANCE;  
    }  
  
}
```

#### 枚举创建单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 枚举创建单例设计模式  
 * 懒加载单例设计模式  
 * 推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome7 {  
    public static void main(String[] args) {  
        Singleton7 instance1 = Singleton7.getInstance();  
        Singleton7 instance2 = Singleton7.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
enum Singleton7 {  
    INSTANCE;  
  
    public static Singleton7 getInstance() {  
        System.out.println("INSTANCE = ok ");  
        return INSTANCE;  
    }  
  
  
}
```
