## 创建形设计模式

### 单例设计模式

> 单例模式就是在整个系统中,**某一个类只能存在一个对象实例**,并且该类只提供一个获取其对象的实例的方法(静态方法)

#### 饿汉式(静态成员属性)单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 缺点: 不是懒加载, 如果没有用到该对象,会照成内存浪费, 单线程(推荐)  
 * 饿汉式(静态成员属性)单例设计模式  
 * 单线程推荐使用  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome1 {  
    public static void main(String[] args) {  
        Singleton1 instance1 = Singleton1.getInstance();  
        Singleton1 instance2 = Singleton1.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton1 {  
  
    // 在属性中直接创建对象  
    private static final Singleton1 instance = new Singleton1();  
  
    //  私有构造方法  
    private Singleton1() {  
    }  
  
    // 提供方法返回单例对象  
    public static Singleton1 getInstance() {  
        return instance;  
    }  
  
}
```

#### 饿汉式(静态代码块)单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 缺点: 不是懒加载, 如果没有用到该对象,会照成内存浪费, 单线程(推荐)  
 * 饿汉式(静态代码块)单例设计模式  
 * 单线程推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome2 {  
    public static void main(String[] args) {  
        Singleton2 instance1 = Singleton2.getInstance();  
        Singleton2 instance2 = Singleton2.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton2 {  
  
    private static final Singleton2 instance;  
  
    // 在静态代码块中直接创建对象  
    static {  
        instance = new Singleton2();  
    }  
  
    //  私有构造方法  
    private Singleton2() {  
    }  
  
    // 提供方法返回单例对象  
    public static Singleton2 getInstance() {  
        return instance;  
    }  
  
}
```

#### 单例设计模式 (线程不安全)

```java
package com.zhou.singleton;  
  
/**  
 * 缺点: 多线程环境创建对象不安全,如 A B 线程同时进入if判断,则会创建两次实例  
 * 懒加载单例设计模式  
 * 不推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome3 {  
    public static void main(String[] args) {  
        Singleton3 instance1 = Singleton3.getInstance();  
        Singleton3 instance2 = Singleton3.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton3 {  
  
    private static Singleton3 instance;  
  
    //  私有构造方法  
    private Singleton3() {  
    }  
  
    // 判断对象是否被创建,创建了就直接返回该对象,没有创建,则创建  
    // 但是多线程环境不适用, 会照成线程不安全  
    public static Singleton3 getInstance() {  
        if (instance == null) {  
            return new Singleton3();  
        }  
        return instance;  
    }  
  
}
```

#### 懒汉式单例设计模式 (线程安全)

```java
package com.zhou.singleton;  
  
/**  
 * 线程安全的单例设计模式  
 * 懒加载单例设计模式  
 * 不推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome4 {  
    public static void main(String[] args) {  
        Singleton4 instance1 = Singleton4.getInstance();  
        Singleton4 instance2 = Singleton4.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton4 {  
  
    private static Singleton4 instance;  
  
    //  私有构造方法  
    private Singleton4() {  
    }  
  
    // 线程安全的创建对象的方法  
    // 但是会造成性能问题,因为每一个线程进入都需要加锁,解锁, 而我们只需要第一次线程加锁,后续不需要  
    public static synchronized Singleton4 getInstance() {  
        if (instance == null) {  
            return new Singleton4();  
        }  
        return instance;  
    }  
  
}
```

#### 懒汉式双重检查单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 解决效率问题和懒加载  
 * 双重检查单例设计模式 (完美解决线程不安全问题和执行效率问题)  
 * 懒加载单例设计模式  
 * 推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome5 {  
    public static void main(String[] args) {  
        Singleton5 instance1 = Singleton5.getInstance();  
        Singleton5 instance2 = Singleton5.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton5 {  
  
    private static volatile Singleton5 instance;  
  
    //  私有构造方法  
    private Singleton5() {  
    }  
  
    // 线程安全的创建对象的方法,解决效率问题  
    public static Singleton5 getInstance() {  
        if (instance == null) {  
            synchronized (Singleton5.class) {  
                if (instance == null) {  
                    return new Singleton5();  
                }  
            }  
        }  
        return instance;  
    }  
  
}
```

#### 懒汉式静态内部类的方式创建单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 解决效率问题,和懒加载问题  
 * 静态内部类的方式创建单例设计模式  
 * 懒加载单例设计模式  
 * 推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome6 {  
    public static void main(String[] args) {  
        Singleton6 instance1 = Singleton6.getInstance();  
        Singleton6 instance2 = Singleton6.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
class Singleton6 {  
  
    // 静态内部内方式创建单例设计模式, 利用jdk 静态内部类特点  
    private static class SingletonInstance {  
        private static final Singleton6 INSTANCE = new Singleton6();  
    }  
  
    //  私有构造方法  
    private Singleton6() {  
    }  
  
    // 线程安全的创建对象的方法,解决效率问题  
    public static Singleton6 getInstance() {  
        return SingletonInstance.INSTANCE;  
    }  
  
}
```

#### 枚举创建单例设计模式

```java
package com.zhou.singleton;  
  
/**  
 * 枚举创建单例设计模式  
 * 懒加载单例设计模式  
 * 推荐使用  
 *  
 * @author zhoufuqi  
 * @date 2022/7/10 12:57  
 */public class SingletonDome7 {  
    public static void main(String[] args) {  
        Singleton7 instance1 = Singleton7.getInstance();  
        Singleton7 instance2 = Singleton7.getInstance();  
        System.out.println(instance1 == instance2);  
        System.out.println("instance2 = " + instance2.hashCode());  
        System.out.println("instance2 = " + instance2.hashCode());  
    }  
}  
  
enum Singleton7 {  
    INSTANCE;  
  
    public static Singleton7 getInstance() {  
        System.out.println("INSTANCE = ok ");  
        return INSTANCE;  
    }  
  
  
}
```

## 工厂模式

> 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
> 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

* 工厂模式优点：
	-   **可以使代码结构清晰，有效地封装变化**。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。
	-   **对调用者屏蔽具体的产品类**。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。
	-   **降低耦合度**。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。

总结
	就是通过工厂模式**不会向客户端暴露创建对象的逻辑**和**屏蔽具体的创建的类的对象**和**降低代码耦合度**

### 简单工厂模式

> 简单工厂模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象
> 简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为**静态工厂方法**模式

* 优点:
	-   一个调用者想创建一个对象，只要知道其名称就可以了。
	-   屏蔽产品的具体实现，调用者只关心产品的接口。



存在的问题:
> 当我们需要增加一种披萨时，例如培根披萨。这个时候我们需要先定义一个类继承 Pizza 类，其中实现准备披萨原材料的代码。除此之外我们还要修改 SimpleFactory 类的代码，增加一个 case/if。这显然是**违背开闭原则**的。可想而知对于新产品的加入，工厂类是很被动的。
> 我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。 简单工厂可能就不太适用了。为了解决这种问题就用到了工厂方法模式了

总结:
	简单工厂模式是通过外接传入的类型,创建相对应的类, **它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了**

### 工厂方法模式

> 定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。
> 工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——工厂方法模式在设计上完全完全符合**开闭原则**。

* 优点:
	-   一个调用者想创建一个对象，只要知道其名称就可以了。
	-   扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
	-   屏蔽产品的具体实现，调用者只关心产品的接口。

缺点:
	每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

总结: 
	工厂方法模式也就是使用面向对象中的多态来实现不同工厂类生产的产品不一样的区别,调用方只需要知道生产产品的工厂然后调用生产产品的对象就行了